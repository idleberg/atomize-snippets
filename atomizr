#!/usr/bin/env ruby

$version = "0.12.0"

require "json"
require "nokogiri"
require "optparse"
require "fileutils"

# Arrays of filters to replace characters in strings
$filename_filter =  [
    [/[\x00\/\\:\*\?\"\$<>\|]/, '_'],
    ["\t",  "-"]
]
$title_filter = [
    [/\x27/, "\\\\'"],  # single-quote
    [/\x22/, "\\\""],   # double-quote
    [/\x5C/, "\\\\"],   # backslash
]
$prefix_filter = [
    [/[\x00\x22\x27\/\\:\*\?\"\'\$<>\{\}\|]/, '']
]
$body_filter = [
    [/\x27/, "\\\\'"],  # single-quote
    [/\x22/, "\\\""],   # double-quote
    [/\x5C/, "\\\\"],   # backslash
]
$scope_filter = [ 
    # https://gist.github.com/idleberg/fca633438329cc5ae317
    [',', ''],
    [/\.?source\.c\+\+/, '.source.cpp'],
    [/\.?source\.java-props/, '.source.java-properties'],
    [/\.?source\.objc\+\+/, '.source.objcpp'],
    [/\.?source\.php/, '.text.html.php'],
    [/\.?source\.scss/, '.source.css.scss'],
    [/\.?source\.todo/, '.text.todo'],
    [/\.?text\.html\.markdown/, '.source.gfm']
]

meta_info = <<-EOF
\nAtomizr, version #{$version}
The MIT License
Copyright (c) 2015 Jan T. Sott
EOF

# Methods
def read_file(input, type)
    if $merge == true
        init_hashes()
    end

    Dir.glob(input) do |item|

        if $merge == false
            init_hashes()
        end

        $data = send("read_#{type}", item)

        if $merge == false
            write_data(item)
        end
    end

    if $merge == true
        write_data($output)
    end
end


def read_xml(item)

    puts "\nReading snippet file '#{item}'"

    # read file, parse data
    file = File.read(item)

    # validate file
    if (valid_xml?(file) == false) && ($no_validation == false)
        abort("\nError: Invalid XML file '#{item}'")
    end

    data = Nokogiri::XML(file)

    if (item.end_with? ".tmSnippet") || ($is_tm == true)
        $data['completions'] = read_textmate_xml(item, data)
    else
        $data['completions'] = read_sublime_xml(item, data)
    end

    $input_counter += 1

    return $data
end

def read_sublime_xml(item, data)

    # get scope
    $data['scope'] = get_scope( data.xpath("//scope")[0].text.strip )

    trigger = data.xpath("//tabTrigger")[0].text.strip

    data.xpath("//content").each do |node|

        title  = filter_str(trigger, $title_filter)
        prefix = filter_str(trigger, $prefix_filter)
        body   = filter_str(node.text.strip, $body_filter)

        if $completions.has_key?(title)
            if $dupes == false
                puts " !! Duplicate trigger #{title.dump} in #{item}"
            else
                abort("\nError: duplicate trigger '#{title.dump}' in #{item}. Triggers must be unique.")
            end
        end

        $completions[title] = {
            :prefix => prefix,
            :body => body
        }
    end

    return $completions
end

def read_textmate_xml(item, data)

    data.xpath('//dict').each do | node |
      node.element_children.map(&:content).each_slice(2) do | k, v |
        case k
        when 'scope'
            $data['scope'] = get_scope(v.to_s)
        when 'name'
            @title = filter_str(v.to_s, $title_filter)
        when 'tabTrigger'
            @prefix = filter_str(v.to_s, $prefix_filter)
        when 'content'
            @body = filter_str(v.to_s.strip, $body_filter)
        else
            next
        end
      end
    end

    $completions[@title] = {
        :prefix => @prefix,
        :body => @body
    }

    return $completions
end

def read_json(item)

    puts "\nReading completion file '#{item}'"

    # read file
    file = File.read(item)

    # validate file
    if (valid_json?(file) == false) && $no_validation == false
        abort("\nError: Invalid JSON file '#{item}'")
    else
        data = JSON.load(file)
    end

    # get scope
    $data['scope'] = get_scope( data["scope"] )

    data["completions"].each do |line|
        trigger = line["trigger"]

        # Next if JSON contains non-standard keys
        if trigger == nil
            puts " >> Ignoring line #{line}"
            next
        end 

        contents = line["contents"]

        title  = filter_str(trigger, $title_filter)
        prefix = filter_str(trigger, $prefix_filter)
        body   = filter_str(contents, $body_filter)

        if $completions.has_key?(title)
            if $dupes == false
                puts " !! Duplicate trigger #{title.dump} in #{item}"
            else
                abort("\nError: duplicate trigger '#{title.dump}' in #{item}. Triggers must be unique.")
            end
        end

        $completions[title] = {
            :prefix => prefix,
            :body => body
        }
    end

     $data['completions'] = $completions

    $input_counter += 1
    return $data
end

# via https://gist.github.com/ascendbruce/7070951
def valid_json?(json)
    JSON.parse(json)
    true
rescue
    false
end

def valid_xml?(xml)
    Nokogiri::XML(xml) { |config| config.options = Nokogiri::XML::ParseOptions::STRICT }
    true
rescue
    false
end

def write_data(item)
    if $output == "json"
        file = get_outname('json', item)
        write_json($data, file, $split)
    else
        file = get_outname('cson', item)
        write_cson($data, file, $split)
    end
end

def write_json(data, file, many = false)

    if many == false

        if $no_comment == true
            json = {
                data['scope'] => data['completions']
            }
        else
            json = {
                :generator => "Atomizr v#{$version} - https://github.com/idleberg/atomizr",
                data['scope'] => data['completions']
            }
        end

        puts "Writing '#{file}'"
        File.open("_output/#{file}","w") do |f|
          f.write(JSON.pretty_generate(json))
        end
        $output_counter += 1

    elsif many == true

        scope = data['scope']

        data['completions'].each do |item|

            file = filter_str(item[1][:prefix], $filename_filter)

            json = {
                data['scope'] => {
                    item[0] => {
                        'prefix' => item[1][:prefix],
                        'body' => item[1][:body]
                    }
                }
            }

            puts "Writing '#{file}.json'"
            File.open("_output/#{file}.json","w") do |f|
              f.write(JSON.pretty_generate(json))
            end
            $output_counter += 1
        end
    end
end

def write_cson(data, item, many = false)

    if many == false

        if $no_comment == true
            comment = ""
        else
            comment =  "# Generated with Atomizr v#{$version} - https://github.com/idleberg/atomizr\n"
        end

        cson = comment
        cson += "'"+data['scope']+"':\n"

        data['completions'].each do |item|

            title = item[0]
            prefix = item[1][:prefix]
            body = item[1][:body]

            cson += "  '"+title+"':\n"
            cson += "    'prefix': '"+prefix+"'\n"
            if body.lines.count <= 1
                cson += "    'body': '"+body+"'\n"
            else
                cson += "    'body': \"\"\"\n"
                body.each_line do |line|
                    cson += "      "+line
                end
                cson +="\n    \"\"\"\n"
            end
        end

        if File.directory?($input[0])
            mkdir("_output/#{$output}/snippets")
            file = $output + '/snippets/' + item + '.cson'
        else
            file = get_outname('cson', item)
        end

        puts "Writing '#{file}'"
        File.open("_output/#{file}","w") do |f|
          f.write(cson)
        end
        $output_counter += 1

    elsif many == true

        scope = data['scope']

        data['completions'].each do |item|

            cson = "'"+scope+"':\n"
            title = item[0]
            prefix = item[1][:prefix]
            body = item[1][:body]

            file = filter_str(prefix, $filename_filter)

            cson += "  '"+title+"':\n"
            cson += "    'prefix': '"+prefix+"'\n"
            if body.lines.count <= 1
                cson += "    'body': '"+body+"'\n"
            else
                cson += "    'body': \"\"\"\n"
                body.each_line do |line|
                    cson += "      "+line
                end
                cson +="\n    \"\"\"\n"
            end

            puts "Writing '#{file}.cson'"
            File.open("_output/#{file}.cson","w") do |f|
              f.write(cson)
            end
            $output_counter += 1
        end
    end
end

def get_outname(type, item)
    if $output == type

        if $input[0].include? "*"
            file = item
        else
            file = $input[0]
        end
        output = File.basename(file, ".*")+"."+type
    else
        output = $output
    end

    return output
end

def get_scope(scope)

    if $scope == nil
        scope = fix_scope(filter_str(scope, $scope_filter))
        puts "Using default scope '"+scope+"'"
    else
        scope = fix_scope(filter_str($scope, $scope_filter))
        puts "Override scope using '"+scope+"'"
    end

    return scope
end

# prepend dot to scope
def fix_scope(scope)
    if scope[0] != "."
        scope = "."+ scope
    end

    return scope
end

def filter_str(input, filter)

    if filter.any?
        filter.each do |needle, replacement|
            input = input.to_s.gsub(needle, replacement)
        end
    end

    return input
end

def init_hashes()
    $data = Hash.new
    $completions = Hash.new
end

def mkdir(folder)
  if !Dir.exists?(folder)
    FileUtils.mkdir_p(folder)
  end
end

def copy_file(src, dest, del = false)
  File.write(dest, File.read(src))

  if del == true
    File.delete(src)
    end
end

# default options
$input_counter  = 0
$output_counter = 0

$scope = nil
$merge = false
$split = false
$dupes = true
$is_tm = false
$no_comment    = false
$no_validation = false

args = ARGV.count
 
# parse arguments
ARGV.options do |opts|
    opts.banner = "\nUsage: atomizr [options]"

    opts.on("-h", "--help", "prints this help") do
        puts meta_info
        puts opts
        exit
    end

    opts.on("-i", "--input=<file>", Array, "Input file(s)") {
        |input| $input = input
    }

    opts.on("-o", "--output=<file>", String, "Output file") {
        |output| $output = output
    }

    opts.on("-s", "--scope=<scope>", String, "overwrite scope") {
        |val| $scope = val
    }

    opts.on("-S", "--split", "split result into multiple files") {
        if $merge != true
            $split = true
        else     
            abort("Error: You can't split AND merge")
        end
    }

    opts.on("-M", "--merge", "merge results into single file") {
        if $split != true
            $merge = true
        else     
            abort("Error: You can't merge AND split")
        end
    }

    opts.on("-C", "--skip-comments", "skip generator comments") {
        $no_comment = true
    }

    opts.on("-D", "--skip-duplicates", "skip duplicate triggers") {
        $dupes = false
    }

    opts.on("-V", "--skip-validation", "skip file validation") {
        $no_validation = true
    }

    opts.on("-T", "--is-textmate", "interprete snippet as TextMate") {
        $is_tm = true
    }

    opts.on_tail("-v", "--version", "show version") do
        puts $version
        exit
    end

    opts.parse!
end

# let's go
puts meta_info

# error handling
if args < 1
    abort("\nError: no arguments passed")
elsif $input == nil
    abort("\nError: no input argument passed")
elsif $output == nil
    abort("\nError: no output argument passed")
end

# Create output directory, if necessary
mkdir("_output")

$input.each do |input|

    if (input.end_with? ".sublime-completions") || (input.end_with? ".json")

        read_file(input, "json")

    elsif (input.end_with? ".sublime-snippet") || (input.end_with? ".tmSnippet")|| (input.end_with? ".xml")

        read_file(input, "xml")

    elsif File.directory?(input)

        unless input.end_with?("/")
            input = input + "/"
        end

        @tm = Hash.new
        @tm['Preferences'] = Dir.glob("#{input}**/*.tmPreferences")
        @tm['Snippets']    = Dir.glob("#{input}**/*.tmSnippet")
        @tm['Syntaxes']    = Dir.glob("#{input}**/*.tmLanguage")

        abort if @tm.empty?

        @parent = '_output/'+$output

        @tm.each do |item|

          next if item[1].empty?

          puts "\nCollecting #{item[0].downcase}:"

          item[1].each do |file|
              puts " + #{file}"

              @base = File.basename(file)
              @parent = '_output/'+$output
              @target = @parent+'/.tmp/'+item[0]+'/'

              mkdir(@target)
              copy_file(file, @target+@base, false)

              $input_counter += 1
          end

        end

        puts "\nConverting with apm"
        system "apm init --package #{@parent} --convert #{@parent}/.tmp"
        FileUtils.rm_rf("#{@parent}/.tmp")

        $output_counter = Dir.glob("#{@parent}/**/*.cson").count

    else
        puts "\nError: Unsupported file passed (#{input})"
    end

end

# Game Over
if $input_counter == 0
    puts "No files converted"
elsif $input_counter == 1
     puts "\nAtomized #{$input_counter} file, created #{$output_counter}"
else
    puts "\nAtomized #{$input_counter} files, created #{$output_counter}"
end