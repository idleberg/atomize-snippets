#!/usr/bin/env ruby

@version = "0.8.1"

require "json"
require "nokogiri"
require "optparse"

# Arrays of filters to replace characters in strings
@filename_filter =  [
    [/[\x00\/\\:\*\?\"\$<>\|]/, "_"],
    ["\t",  "-"]
]
@title_filter = [
    # [find, replace]
]
@prefix_filter = [
    [/[\x00\/\\:\*\?\"\$<>\|]/, '']
]
@body_filter = [
    # [find, replace]
]
@scope_filter = [
    # https://gist.github.com/idleberg/fca633438329cc5ae317
    [',', ''],
    [/\.?source\.c\+\+/, '.source.cpp'],
    [/\.?source\.java-props/, '.source.java-properties'],
    [/\.?source\.objc\+\+/, '.source.objcpp'],
    [/\.?source\.php/, '.text.html.php'],
    [/\.?source\.scss/, '.source.css.scss'],
    [/\.?source\.todo/, '.text.todo'],
    [/\.?text\.html\.markdown/, '.source.gfm']
]

meta_info = <<-EOF
\nAtomizr, version #{@version}
The MIT License
Copyright (c) 2015 Jan T. Sott
EOF

# Methods
def read_xml(item)

    puts "\nReading snippet file '#{item}'"

    # read file, parse data
    file = File.read(item)
    data = Nokogiri::XML(file)

    # get scope
    @data['scope'] = get_scope( data.xpath("//scope")[0].text.strip )

    trigger = data.xpath("//tabTrigger")[0].text.strip

    data.xpath("//content").each do |node|

        title  = filter_str(trigger, @title_filter)
        prefix = filter_str(trigger, @prefix_filter)
        body   = filter_str(node.text.strip, @body_filter)

        if @completions.has_key?(title)
            if @dupes == false
                puts " !! Duplicate trigger '#{title}' in #{item}"
            else
                abort("\nError: duplicate trigger '#{title}' in #{item}. Triggers must be unique.")
            end
        end

        @completions[title] = {
            :prefix => prefix,
            :body => body
        }
    end

    @data['completions'] = @completions

    return @data
end

def read_json(item)

    puts "\nReading completion file '#{item}'"

    # read file, parse data
    file = File.read(item)
    data = JSON.load(file)

    # get scope
    @data['scope'] = get_scope( data["scope"] )

    data["completions"].each do |line|
        trigger = line["trigger"]

        # Next if JSON contains non-standard keys
        if trigger == nil
            puts " >> Ignoring line #{line}"
            next
        end 

        contents = line["contents"]

        title  = filter_str(trigger, @title_filter)
        prefix = filter_str(trigger, @prefix_filter)
        body   = filter_str(contents, @body_filter)

        if @completions.has_key?(title)
            if @dupes == false
                puts " !! Duplicate trigger '#{title}' in #{item}"
            else
                abort("\nError: duplicate trigger '#{title}' in #{item}. Triggers must be unique.")
            end
        end

        @completions[title] = {
            :prefix => prefix,
            :body => body
        }
    end

     @data['completions'] = @completions

    return @data
end

def write_data(item)
    if @output == "json"
        file = get_outname('json', item)
        write_json(@data, file, @split)
    else
        file = get_outname('cson', item)
        write_cson(@data, file, @split)
    end

    @input_counter += 1
end

def write_json(data, file, many = false)

    if many == false

        json = {
            data['scope'] => data['completions']
        }

        puts "Writing '#{file}'"
        File.open("_output/#{file}","w") do |f|
          f.write(JSON.pretty_generate(json))
        end
        @output_counter += 1

    elsif many == true

        scope = data['scope']

        data['completions'].each do |item|


            file = filter_str(item[1][:prefix], @filename_filter)

            json = {
                data['scope'] => {
                    item[0] => {
                        'prefix' => item[1][:prefix],
                        'body' => item[1][:body]
                    }
                }
            }

            puts "Writing '#{file}.json'"
            File.open("_output/#{file}.json","w") do |f|
              f.write(JSON.pretty_generate(json))
            end
            @output_counter += 1
        end
    end
end

def write_cson(data, item, many = false)

    if many == false

        cson = "'"+data['scope']+"':\n"

        data['completions'].each do |item|

            title = item[0]
            prefix = item[1][:prefix]
            body = item[1][:body]

            cson += "  '"+title+"':\n"
            cson += "    'prefix': '"+prefix+"'\n"
            if body.lines.count <= 1
                cson += "    'body': '"+body+"'\n"
            else
                cson += "    'body': \"\"\"\n"
                body.each_line do |line|
                    cson += "      "+line
                end
                cson +="\n    \"\"\"\n"
            end
        end

        file = get_outname('cson', item)

        puts "Writing '#{file}'"
        File.open("_output/#{file}","w") do |f|
          f.write(cson)
        end
        @output_counter += 1

    elsif many == true

        scope = data['scope']

        data['completions'].each do |item|

            cson = "'"+scope+"':\n"
            title = item[0]
            prefix = item[1][:prefix]
            body = item[1][:body]

            file = filter_str(prefix, @filename_filter)

            cson += "  '"+title+"':\n"
            cson += "    'prefix': '"+prefix+"'\n"
            if body.lines.count <= 1
                cson += "    'body': '"+body+"'\n"
            else
                cson += "    'body': \"\"\"\n"
                body.each_line do |line|
                    cson += "      "+line
                end
                cson +="\n    \"\"\"\n"
            end

            puts "Writing '#{file}.cson'"
            File.open("_output/#{file}.cson","w") do |f|
              f.write(cson)
            end
            @output_counter += 1
        end
    end
end

def get_outname(type, item)
    if @output == type
        if (@input.start_with? "*.") || ((@input.end_with? ".*"))
            file = item
        else
            file = @input
        end
        output = File.basename(file, ".*")+"."+type
    else
        output = @output
    end

    return output
end

def get_scope(scope)

    if @scope == nil
        scope = filter_str(scope, @scope_filter)
        puts "Using default scope '"+scope+"'"
    else
        if @scope[0] != "."
            scope = "."+ @scope
        else
            scope = @scope
        end
        scope = filter_str(scope, @scope_filter)
        puts "Override scope using '"+scope+"'"
    end

    return scope
end

def filter_str(input, filter)

    if filter.any?
        filter.each do |needle, replacement|
            input = input.to_s.gsub(needle, replacement)
        end
    end

    return input
end

def init_hashes()
    @data = Hash.new
    @completions = Hash.new
end

# default options
@input_counter  = 0
@output_counter = 0

@scope = nil
@merge = false
@split = false
@dupes = true
@array = []

args = ARGV.count
 
# parse arguments
ARGV.options do |opts|
    opts.banner = "\nUsage: atomizr [options]"

    opts.on("-h", "--help", "prints this help") do
        puts meta_info
        puts opts
        exit
    end

    opts.on("-i", "--input=<file>", String, "Input file(s)") {
        |input| @input = input
    }

    opts.on("-o", "--output=<file>", String, "Output file") {
        |output| @output = output
    }

    opts.on("-s", "--scope=<scope>", String, "overwrite scope") {
        |val| @scope = val
    }

    opts.on("-S", "--split", "split result into multiple files") {
        if @merge != true       
            @split = true        
        else     
            abort("Error: You can't split AND merge")
        end
    }

    opts.on("-M", "--merge", "merge result into single file") {
        if @split != true       
            @merge = true        
        else     
            abort("Error: You can't merge AND split")       
        end
    }

    opts.on("-D", "--allow-duplicates", "allow duplicate triggers") {    
        @dupes = false
    }

    opts.on_tail("-v", "--version", "show version") do
        puts @version
        exit
    end

    opts.parse!
end

# let's go
puts meta_info

if args < 1
    abort("\nError: no arguments passed")
end

# Create output directory, if necessary
if !Dir.exists?("_output")
    puts "\nCreate output directory"
    Dir.mkdir("_output")
end

if (@input.end_with? ".sublime-completions") || (@input.end_with? ".json")

    if @merge == true
        init_hashes()
    end

    Dir.glob(@input) do |item|

        if @merge == false
            init_hashes()
        end

        @data = read_json(item)

        if @merge == false
            write_data(item)
        end
    end

    if @merge == true
        write_data(@output)
    end

elsif (@input.end_with? ".sublime-snippet") || (@input.end_with? ".xml")

    if @merge == true
        init_hashes()
    end

    Dir.glob(@input) do |item|

        if @merge == false
            init_hashes()
        end

        @data = read_xml(item)

        if @merge == false
            write_data(item)
        end
    end

    if @merge == true
        write_data(@output)
    end
else
    puts "\nError: Unknown file passed (#{@input})"
end

# Game Over
if @input_counter == 0
    puts "No files converted"
elsif @input_counter == 1
     puts "\nAtomized #{@input_counter} file, created #{@output_counter}"
else
    puts "\nAtomized #{@input_counter} files, created #{@output_counter}"
end